package t7_mysql;

public class Topic1 {
    /*
            1.索引及查询优化
            （1）B+树
                B树
                    B树（B-tree）是一种树状数据结构，
                    它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。
                    B树，概括来说是一个节点可以拥有多于2个子节点的查找树。
                    与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。

                  B树特征：
                    1.根结点至少有两个子女。
                    2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
                    3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
                    4.所有的叶子结点都位于同一层。
                    5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

                B+树
                    对B树的改进：
                        1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素）；
                        2.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素；
                        3.每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
                        4.最后一层的所有节点形成一个链表（Mysql为了增加区间查询性能做的优化）

                为什么选择B+树，而不是红黑树呢？
                    局部性原理：时间局部性、空间局部性
                    操作系统读取数据时，一次会读取一页（貌似2KB）的数据到内存，（利用了局部性原理）
                    B+树中，一个节点就是一页的大小，而索引中B+树，它的层级一般是3层，也就意味着我们需要3次IO。
                    数据库查询的最大的瓶颈就是IO！
                    所以，B+树能减少我们进行IO的次数。

                    红黑树深度是极高的，我要查重一个数据，需要加载很多页，也就是需要进行很多次IO，显然性能会变差。
                    另一方面，叶子节点的链表优化了连续查找的性能。

                https://www.cnblogs.com/vincently/p/4526560.html

            （2）InnoDB & MyIsam索引实现
                明确几个概念：
                    二级索引
                    聚集索引：叶子节点包含数据行的所有信息。
                    主键索引：
                    组合索引：

                InnoDB的主键索引是聚集索引，即包含了数据行的所有信息。
                InnoDB的二级索引（辅助索引）叶子包含的数据就是该行的主键。

                MyIsam的主键索引、以及二级索引的叶子节点存放的都是指向数据行的指针。


            （3）执行计划（explain）
                explain  查询语句
                会得到如下信息：
                    table | type | possible_keys | key | key_len | ref | rows | Extra

                下面来一一介绍这些信息：

                table：显示这一行的数据是关于哪张表的

                type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL
                      说明：不同连接类型的解释（按照效率高低的顺序排序）（名字叫"访问类型"，更贴切）

                        system：表只有一行：system表。这是const连接类型的特殊情况。
                        const ：表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。
                                因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待。
                        eq_ref：在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，
                                它在查询使用了索引为主键或惟一键的全部时使用。
                        ref：这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。
                                对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。
                        range：这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况。
                        index：这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）。
                        ALL：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。

                possible_keys：显示可能应用在这张表中的索引。
                key：实际使用的索引。
                key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好
                ref：显示索引的哪一列被使用了，如果可能的话，是一个常数
                rows：MYSQL认为必须检查的用来返回请求数据的行数
                Extra：关于MYSQL如何解析查询的额外信息。这里可以看到的坏的例子是Using temporary和Using filesort，

                Using filesort ： 看到这个的时候，查询就需要优化了。mysql需要进行额外的步骤来发现如何对返回的行排序。
                                  它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。

                Using index ：    列数据是从仅仅使用了索引中的信息而没有读取"聚集索引表"的表返回的，
                                  这发生在对表的全部的请求列都是同一个索引的部分的时候。(覆盖索引)

                Using temporary ：看到这个的时候，查询需要优化了。这里，mysql需要创建一个临时表来存储结果，
                                  这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。

            （4）SQL调优
                1.合理的使用索引
                    最左前缀原则
                        最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
                        比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
                        如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
                    使用覆盖索引(避免回表查询)
                    使用索引排序（而不是file sort）
                    主键使用合适的数据类型
                    识别索引的区分度
                    使用执行计划，检查语句是否走到合适的索引
                    （有些情况下不会走合适的索引，比如<>, in 等情况，不过高版本的优化器可能做了优化）
                    ...

                2.适当违反三大范式，增加冗余
                    在表里增加一些与主键不直接相关的列。
                3.Join内连接的优化：小表驱动大表（Mysql优化器可优化、减少循环次数），在被驱动表中连接的字段要走索引
                                  EXPLAIN 结果中，第一行出现的表就是驱动表（Important!）
            2.事务（几乎必考）：
                事务的ACID四个特性
                    Atomic（原子性）：事务中的操作，要么都成功，都失败
                    Consistency（一致性）：被约束的数据要处在一个一致的状态
                    Isolation（隔离性）：事务之间互相影响，保证同时执行的事务互相之间没有干扰
                    Durability（持久性）：存到磁盘中，即使机器断电，数据还是有的

                并发事务带来的几个问题：更新丢失，脏读，不可重复读，幻读。

                Mysql事务的四种隔离级别：

                    隔离级别	            脏读	    不可重复读   幻读
                    read uncommitted	允许	    允许	        允许
                    read committed		        允许	        允许
                    repeatable read（默认）			        允许
                    serializable

                https://www.jianshu.com/p/0b245d972e23

            3.JOIN
                左连接，右连接，内连接，全连接（Mysql 不支持全连接）

            4.底层原理
                redo log（WAL，write ahead log）
                undo log
                binlog
                MVCC：为每个数据增加一个版本号，每次修改会对该记录版本号递增，
                      可重复读（RR），读取事务开始前最新的版本号；
                      读已提交（RC），每次读取最新的数据。

            5.乐观锁、悲观锁
                乐观锁：
                    通过 where 条件中的版本号来确定是否更新，版本号递增，当版本号相同时才做修改操作。

                悲观锁：
                    排他锁：for update

                    共享锁：in share mode（只能读）

                    行锁、表锁
                        innodb，走索引，能走到行锁

            6.InnoDB 和 MyIsam 区别
                InnoDB（默认，公司用的都是这个）
                    1、支持事务处理、ACID事务特性；
                    2、实现了SQL标准的四种隔离级别；
                    3、支持行级锁和外键约束；
                    4、锁级别为行锁，行锁优点是适用于高并发的频繁表修改，高并发是性能优于 MyISAM。缺点是系统消耗较大。
                    5、索引存储数据（聚集索引），相比 MyISAM 需要更大的内存。

                MyIsam
                    1.高性能读取；
                    2.因为它保存了表的行数，当使用COUNT统计时不会扫描全表
                    3.支持全文本索引（更好的选择是EleasticSearch）

            7.关系型数据库设计三大范式（考点，三大范式是关系型数据库 表设计的指导思想）
                （1）每个属性都是原子的（必须遵循的，方便查询）
                （2）表中每个列都和主键相关(也是要遵循的)
                （3）表中的每列和主键直接相关

     */
}
