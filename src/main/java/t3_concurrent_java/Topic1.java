package t3_concurrent_java;

public class Topic1 {
/*
    1.线程与进程
       1.进程、线程区别:
            （1）进程是资源分配的最小单位，线程是程序执行的最小单位。
                一个JVM就是一个进程，我们可以通过jps命令查看正在运行的进程；
                进程有自己独立的内存空间，而线程没有，线程共享所在进程的内存空间。
            （2）进程更重量级，与线程相比，创建、销毁进程都更耗时。
            （3）线程之间的通信更方便，同一进程下的线程共享内存，而进程之间的通信需要以通信的方式（IPC)进行。
                不过如何处理好同步与互斥是编写多线程程序的难点。
            （4）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，
                而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
        
       2.进程间通信（能说出几种即可）
            1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在父子进程间使用。
            2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
            4. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
            5. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
            6. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
            7. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
            8. 信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
            https://www.cnblogs.com/LUO77/p/5816326.html

       3.Runnable、Thread(例子)
            Java中两种方法实现线程，实现Runnable，继承Thread，
            推荐前者（实现接口，能继承其他类，便于共享资源，能使用于线程池 https://blog.csdn.net/u013755987/article/details/51855098）。

       4.线程的中断
            （1）每个线程都有一个与之相关联的 Boolean 属性，用于表示线程的中断状态（interrupted status）。中断状态初始时为 false。
            当另一个线程通过调用 Thread.interrupt() 中断一个线程时，会出现以下两种情况之一。
            （2）如果那个线程在执行一个低级可中断阻塞方法，例如 Thread.sleep()、 Thread.join() 或 Object.wait()，那么它将取消阻塞并抛出 InterruptedException。
            否则， interrupt() 只是设置线程的中断状态。 在被中断线程中运行的代码以后可以轮询中断状态，看看它是否被请求停止正在做的事情。
            （3）中断是一种协作机制。当一个线程中断另一个线程时，被中断的线程不一定要立即停止正在做的事情。相反，中断是礼貌地请求另一个线程在它愿意并且方便的时候停止它正在做的事情。
            中断状态可以通过 Thread.isInterrupted() 来读取，并且可以通过一个名为 Thread.interrupted() 的操作读取和清除。
            https://www.ibm.com/developerworks/cn/java/j-jtp05236.html

       5.线程状态
            1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
            2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
                              线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法，该状态的线程即为可运行线程，等待被线程调度选中，
                              获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
            3. 阻塞(BLOCKED)：表示线程阻塞于锁。
            4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。（几种情况：等待条件变量、Thread.yield()、thread.join()等）
            5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
            6. 终止(TERMINATED)：表示该线程已经执行完毕。
            https://blog.csdn.net/pange1991/article/details/53860651/

       6.线程的join方法
            在A线程中调用B.join()即等待B执行完毕，A线程再继续执行，同样该方法有超时版本。
            https://www.cnblogs.com/aboutblank/p/3631453.html

       7.线程的优先级
            知道即可。
            线程的优先级用数字来表示，默认范围是1到10，即Thread.MIN_PRIORITY到Thread.MAX_PRIORTY.一个线程的默认优先级是5，即Thread.NORM_PRIORTY
            对优先级操作的方法：
            int getPriority():得到线程的优先级
            void setPriority(int newPriority):当线程被创建后，可通过此方法改变线程的优先级
            必须指出的是：线程的优先级无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大。

       8.守护线程
            知道即可。
            在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)。
            Daemon的作用是为其他线程的运行提供服务，比如说GC线程。其实User Thread线程和Daemon Thread。
            守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。
            void setDaemon(boolean on)

 */
}
