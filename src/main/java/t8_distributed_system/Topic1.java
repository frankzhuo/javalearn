package t8_distributed_system;

public class Topic1 {
    /*
        1.Redis
            （1）单线程，"内存"存储数据，非阻塞IO以及IO多路复用技术

            （2）用途：缓存，递增序号生成器，分布式锁

            （3）数据类型
                （1）string
                （2）hash
                （3）list
                （4）set
                （5）zset：有序的set

            （4）编码
                redis中每种数据类型有不同的编码方式，redis会根据情况选择合适的编码方式；（CPU资源和存储资源之间的权衡）

            （5）纯内存存储，IO多路复用技术、非阻塞IO，单线程架构造就Redis高性能
            （6）持久化（断电了、宕机了，数据还是能够恢复）
                RDB（Redis DataBase）、AOF（Append-Only File）
                RDB：
                    fork一个新的子进程，把当前数据生成快照，保存到硬盘中
                    优点：
                        a.RDB文件是压缩的二进制文件，保存了某个时间点的Redis数据快照，适用于备份、全量复制场景；
                        b.数据恢复速度远快于AOF方式。
                    缺点：
                        a.没法做到实时持久化、秒级持久化(频繁fork进程，执行成本过高)

                AOF：
                    将执行的每一条命令以文本形式记录在单独的文件中，（类似于Mysql的binlog）
                    与RDB不同的是，AOF是增量的形式。
                    优点：
                         a.有不同的sync策略，不需要fork进程，执行成本低，可以做到实时持久化；
                    缺点：
                         a.持久化文件较大
                         b.和redis写使用同一进程，对性能有一定影响

                当对数据完整性要求不高时（可以容忍几分钟的数据损失），可以只采用RDB持久化策略；
                当对数据完整性要求高的时候，需要开启AOF存储，syn策略一般为每秒写盘一次。

            （7）高可用（可提供服务的时间比例高）
                主从结构
                    主Redis —— 从Redis
                    一主一从，一主多从、树状主从结构
                    一般主节点提供写服务，从节点提供读服务（也使读的性能得到了提高）

                主节点发生故障，需要从节点承担主节点职能，这时需要人工手动介入配置
                （更改应用方主节点IP，晋升从节点为主节点，配置其它从节点从新的主节点复制数据）；
                  |
                  |
                哨兵机制：
                    如图（了解即可）

            （8）高性能（主备、集群、一致性hash算法、虚拟节点）
                主从结构中，主写，从读可以提高redis服务的读性能，但是写性能依旧是瓶颈；
                可以通过"集群"的方式来解决redis服务的"写性能"瓶颈
                Redis集群分区的实现：
                    一致性hash算法
                    普通的hash算法，即取余法，当某一节点失效时，所有节点都需要变动。

                    而一致性hash算法中，key取余后分配到对应的节点，而所有节点按顺序组成一个环，
                    当某一节点失效后，该节点的所有数据移动到临近的一个节点上，而不进行全量的重新计算和移动

                    一致性hash算法的问题：数据倾斜问题（某一节点失效后，导致临近的节点数据量过大）；
                      |
                    解决方法：虚拟节点法，例如：设置100个虚拟节点，key按取余法映射到虚拟节点上，
                            再将虚拟节点平均分配到物理节点上，当某一物理节点失效后，将其承载的虚拟节点
                            平均分配到其它物理节点上，避免数据倾斜。

            （9）Jedis
                我们可以通过命令行，使用命令操作redis
                在程序中，会依赖相应的组件库，java中就是Jedis，有些公司会在jedis的基础上进行封装

            （10）常见面试题：
                （1）redis和memcached的比较：
                    1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。
                    2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；
                    3、虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；
                    4、redis是单线程的，memcached是多线程的；
                       当单机redis实例数目等于处理器核数时，redis性能会好些，避免了进程间的通信、同步
                    5、redis支持RDB、AOF两种持久化机制，memcached不支持持久化；
                    6、灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；
                    7、Redis支持数据的备份，即master-slave模式的数据备份；
                    8、应用场景不一样：Redis出来作为NoSQL数据库使用外，还能用做分布式锁、消息队列、数据堆栈和数据缓存等；
                       Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。

                （2）redis如何实现分布式锁？
                    set key value PX 100 NX  （一条命令设置key，过期时间，不存在才能设置）
                    key是我们锁的关键词
                    考虑这样一个场景：
                        对一个订单进行一系列操作，需要保证在同一时刻一个订单，只能同一服务的多个实例中只有一个实例处理，
                        此时，需要使用分布式锁，并且采用订单号拼装key。
                    http://doc.redisfans.com/string/set.html

                （3）你知道的redis的命令（https://www.cnblogs.com/kevinws/p/6281395.html）
                    keys：生产环境不能使用
                    get key
                    set key value
                    del key
                    setnx key value：设置，当且仅当key不存在
                    incr key
                    等等
                    使用请查表：http://doc.redisfans.com

                （4）redis支持哪些数据类型？

                （5）RDB和AOF的区别？

                （6）什么是一致性哈希算法？什么是哈希槽(虚拟节点)？


                （7）使用过Redis做消息队列么，你是怎么用的？
                    一般使用list结构作为队列
                    1. rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
                    2. rpush生产消息，blpop消费消息，阻塞消费，不需要sleep

                    多个消费者消费，怎么实现？有什么缺点？
                        使用redis的pub/sub（发布订阅）功能，
                        缺点是当消费者下线时，这中间产生的消息会丢失，即没有消息堆积的能力；
                        另外，redis作为消息队列，性能和易用性也不如专业的消息队列。

        2.MQ（message queue）
            RocketMQ、Kafka、RabbitMQ等
            MQ并不神秘，

            作用：
                1. 解耦
                2. 流量削峰（削峰填谷）
                3. 消息分发

            常见的MQ：
                RabbitMQ
                RocketMQ
                Kafka

            MQ中常见概念（以RocketMQ为例）：
              组成：
                1. Nameserver
                2. Broker（Master/Slave）
                3. Producer
                4. Consumer
              使用：
                1. Topic
                2. tag
                用来对消息进行分类，topic标志应用，tag标志消息类型

              常见问题：
                1. 消息重复，幂等处理

                2. 消息的顺序性（Topic不是全局有序，但可以做到部分有序）

                消息可靠性、mq可用性、消息积压等问题

        3.秒杀问题
            秒杀，它是一个高并发的问题，大家可以通过秒杀看看高并发问题一般是怎么处理的。
            （1）多个无状态服务实例，做负载均衡

            （2）削峰
                消息队列
                减少秒杀请求时间，解耦秒杀请求服务和秒杀处理服务，同时超过数目的请求直接丢弃不处理
                （进入消息队列前，做更少的操作，这样能提高我们的QPS）

            （3）减库存
                redis
                redis单线程机制保证商品不会超卖，同时redis的高性能减少了请求处理时间。
                避免mysql并发瓶颈。

            （4）展示
                轮训获取，前端异步获取结果

        4.缓存
            缓存可以分为本地缓存（LinkedHashMap，Guava的Cache），缓存服务（分布式缓存）。
            现在，大多数互联网公司使用redis作为缓存。

            分布式缓存存在的一些问题：
                1.缓存雪崩
                    大量缓存同时过期，导致缓存同时更新，给数据库服务器带来巨大压力。
                    解决：
                        避免发生：
                            失效时间设置成随机值
                            通过分布式锁或者队列，控制对于同一个key，读取不到值后更新缓存的数量
                        发生后的防范：
                            redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。
                            本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。

                2.缓存穿透
                    大量查找不存在的key，导致大量对数据库的访问，使数据库宕机。
                    解决：
                        -1，mysql不存在，每次都查询数据库，
                        这个时候，查询到-1不存在，我就往redis中存入一个无效值，下次请求来的时候就能查询到redis，就知道这个请求无效了

                3.数据库更新时的缓存问题
                    几种方案（这些方案可能并不合理）
                    （1）更新数据库，更新缓存
                          更新缓存，是不可以接受的！！！
                          （先更新缓存，后更新数据库有同样的问题）
                          三个请求，更新数据库的顺序是1，2，3；但更新缓存的顺序可能是2，3，1。
                    （2）更新数据库，删除缓存
                          删除成功时：
                              更新缓存时，数据库肯定已经已经被更新，得到的就是最新的值。
                              缓存中的值肯定是最新的值。
                          删除不成功：
                              缓存和数据库产生不一致。

                    （3）删除缓存，更新数据库
                          先保证删除成功，再更新数据库，更新数据库不成功不影响一致性。

                          问题：
                            删除缓存，更新数据库之间，有新的查询请求到来，就会读到旧的值，又会导致数据库和缓存不一致。

                          解决：
                            （1）删除缓存，更新数据库，删除缓存（更大的减少了不一致发生的可能）
                            （2）删除缓存，更新数据库：删除缓存、更新数据库操作，和缓存赋值操作放入一个有序队列中，
                                                   保证了数据库和缓存更新的有序性（多个更新操作可能还要进行合并）。
                4.可用性问题

                5.容量问题

                6.并发问题

        5.共享Session问题
            单点登录，
            session信息写入Redis，
            再次请求时，会根据cookie中的sessionId去redis查询session
            更具session明确权限（简单版，不同数字对应不同权限等级；复杂版，设置权限角色关联表，更灵活分配权限）

            写入session前，可以使用分布式锁。

        6.分布式锁
            分布式场景下，为了数据多个实例正确处理，我们需要使用分布式锁。

            （1）数据库乐观锁实现：
            （2）redis实现分布式锁：
                https://www.cnblogs.com/linjiqin/p/8003838.html

                如何避免死锁？
                    设置超时时间。

            （3）zookeeper实现分布式锁

            思考题：利用Redis实现一个"可重入"，"可自旋等待"的分布式锁


     */
}
