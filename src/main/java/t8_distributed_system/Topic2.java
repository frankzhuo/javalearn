package t8_distributed_system;

public class Topic2 {
    /*
        微服务 基本组件
          1. 为什么要有"微服务"？
            （1）微服务的优点
                1. 易于维护
                2. 弹性（可以很好的处理服务不可用和降级）
                3. 可伸缩（只需对存在性能瓶颈的微服务进行扩展）
                4. 易于开发，简化部署（单体服务只改了一行代码就要重新部署，风险大；导致部署频率变低，这又导致不同版本差异大，风险变大）
                5. 与团队组织结构相匹配（康威定律）
                6. 可组合（针对不同平台，web，原生应用，移动web，穿戴设备）
                7. 可替代性强（可以轻易的重写或删除应用）
                8. 技术异构性（用合适的，新的）

            （2）微服务的缺点
                 1.分布式复杂性(业务上，技术上)
                 2.破坏了系统的一致性

                 最终一致性
                    CAP
                        Consistency:一致性，多个操作都能生效；
                        Availability：可用性，客户请求能够在服务端正确被响应；
                        Partition tolerance：分区容忍性，分区中部分节点挂了，不会影响整体服务可用性。

                        分布式系统必须P，所以对于某一操作，系统就要在C和A中进行选择。

                    BASE
                        BASE理论是对CAP理论的进一步扩充
                        Basically Available：基本可用（不保证100%可用性，保证3个9，或者4个9）
                        Soft State：软状态（允许系统中存在中间状态）
                        Eventually Consistency：弱一致性、最终一致性（多个操作状态最终达到一致）

                 3.运维复杂性
                 4.测试复杂性

            （3）分布式系统的发展：
                SOA（面向服务的架构） --->  微服务(Netflix：Spring Cloud)  --->  Service Mesh（服务网格）

                微服务的概念更重要的是业务的粒度，Spring Cloud只是实现微服务架构的技术手段（也可以说是一种生态），
                同样dubbo也拥有同样的生态，网上有很多关于这两种生态的比较。

                微服务是一个比较大的话题，它一方面涉及具体的业务的划分（具体可以学习"领域驱动设计"），另一方面有涉及分布式系统的具体技术；这两者其实都很重要；
                但前者需要我们在实际项目中积累更多的经验，后者我们可以通过搭建简单的系统得到"管中窥豹"的效果；总之更多的，我认为还是要结合场景来分析。

          2. 微服务有哪些组件？
                （1）服务注册与发现
                （2）服务框架（RPC框架）
                    RPC调用的方式：RPC、HTTP
                    序列化方式
                    RPC-> 基于TCP连接，短链接、长连接，分别适用于哪些场景？

                （3）服务网关
                    Zuul，权限认证（鉴权方面的安全性）、限流、软路由（灰度发布）
                （4）配置中心

                （5）服务追踪

                （6）限流（限制单位时间内的请求数）
                    熔断（服务健康性不好的时候，响应不可用）
                    降级（响应不可用，比如直接返回"服务不可用"）
                    隔离（使不同类型的服务之间互不影响）
                        Hystrix

                dubbo
                Spring Cloud

          3. 分布式事务：
            （1）本地单机事务概念回顾：
                 数据库本地事务要满足ACID，
                 事务的隔离性（I）是通过数据库锁的机制实现的，持久性（D）通过redo log（重做日志）来实现，
                 原子性（A）和一致性（C）通过Undo log来实现。
            （2）分布式事务概念简介：
                 正式版：
                    分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
                 通俗版：
                    就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，
                 分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

            （3）分布式事务的基础理论
                 CAP：
                    C (一致性):
                            对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，
                            那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。
                    A (可用性)：
                            非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合
                            理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。
                    P (分区容错性):
                            当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作
                    CAP不能全部满足，对于分布式系统，要么是CP，要么是AP。
                        CP：zookeeper。
                        AP：BASE是基于AP来扩展的。

                 BASE：
                    Basically Available(基本可用)、Soft state(软状态)、Eventually consistent(最终一致性)
                    BASE是对CAP中AP的一个扩展
                    （1）基本可用:
                            分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。
                    （2）软状态:
                            允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。
                           （中间状态时：多个节点数据不一致）
                    （3）最终一致性:
                            最终一致是指经过一段时间后，所有节点数据都将会达到一致。

                    BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。
                    BASE不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

            （4）不要过度设计，分布式事务会带来复杂性

            （5）分布式事务的实现手段
                 二阶段提交、柔性补偿事务、本地消息表、MQ事务消息

                 二阶段提交（2PC）：
                    如图2PC.jpg，2PC事务包含两种角色：事务管理器、资源管理器（DB）

                    第一阶段：
                        事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.(事务开启，上锁)
                    第二阶段：
                        事务协调器要求每个数据库提交数据，或者回滚数据。

                    优点：
                        尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。

                    缺点:
                        单点问题:
                            事务管理器是单点
                        同步阻塞:
                            在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
                        数据不一致:
                            两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，
                            比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，
                            其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。
                   总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。

                 柔性补偿事务（TCC，Try-Confirm-Cancel）：
                    TCC其实就是采用"补偿事务"的机制，其核心思想史，针对每个操作，都注册一个对应的"确认"和"补偿"（撤销）操作。
                    TCC分为三个阶段：
                        Try阶段：
                            主要是对业务系统做检测及资源预留（资源先被冻结起来）

                        Confirm阶段：
                            主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认Confirm阶段是不会出错的。
                            即：只要Try成功，Confirm一定成功。

                        Cancel阶段：
                            主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
                    优点：
                        强隔离性，严格一致性要求的业务活动
                        适用于执行时间较短的业务，（比如处理账户，收费等业务）
                    缺点：
                        实现成本较高
                        对业务系统有一定的侵入性

                 本地消息表（异步确保）：
                    核心：在分布式事务发起者处维护一个本地消息表。
                    构造买商品的场景，假设操作分为2步，账户服务扣钱，商品服务减库存，具体过程如下：
                     （1）账户服务在同一事务中，扣钱，并在本地消息表中插入一条扣库存消息；
                     （2）事务提交后，向消息队列发送一条减库存消息；
                     （3）商品服务座位消息消费者，根据消息进行库存的扣减；
                     （4）商品服务成功扣减库存后，调用账户服务接口，让账户服务将消息表对应消息的状态更新为成功

                     异常情况的保护：
                     （1）账户服务定时扫描未成功处理的消息，进行重新发送；
                     （2）商品服务保证消息消费的幂等性；
                     （3）定期进行对账，对异常订单进行手工处理（一般较少出现，没必要再去开发自动处理逻辑）

                     优点：
                        避免了阻塞，实现了最终一致性
                     缺点：
                        消息表耦合到业务逻辑中

                 MQ事务消息（异步确保、可靠消息最终一致性）：
                    事务消息介绍：
                        MQ事务消息保证"本地事务和消息发送同时执行成功或失败"：
                        （1）发送prepare消息，该消息对Consumer不可见
                        （2）执行本地事务
                        （3）若本地事务执行成功，则向MQ提交消息确认发送指令；若本地事务执行失败，则向MQ发送取消指令
                        （4）如果有消息没有得到确认，MQ会向消息发送者确认交，在RocketMQ中是以listener的形式让发送者处理
                        https://rocketmq.apache.org/docs/transaction-example/（RocketMQ官网提供的事务消息示例）

                    RocketMQ实现了事务消息：https://www.jianshu.com/p/c26b3af5880f（进一步，想想实现原理）
                    MQ事务消息实际上把"本地消息表"中的消息表移动到了MQ内部，由MQ维护消息的状态。
                    事务发起方，只保证本地事务完成和MQ消息投递，远端事务的完成由MQ保证。

                    优点：
                        消息数据独立存储，独立伸缩
                        降低业务系统与消息系统间的耦合
                        业务被动方实现成本较低
                    缺点：
                        发送一条消息，需要通信2次
                        大部分MQ不支持此功能

                 Saga事务：
                    Saga核心思想：
                        将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，
                        如果某个步骤失败，则根据相反顺序一次调用补偿操作。
                    具体地说，
                        每个Saga由一系列sub-transaction - Ti组成，每个Ti都有对应的补偿动作Ci，
                        补偿动作用于撤销Ti造成的结果，这里的每个Ti，都是一个本地事务。

                    和TCC相比，Saga没有“预留try的冻结”操作，它的Ti就是直接提交到库。

                    比TCC更简单，但saga模式没有实现隔离性，很多场景需要自己实现


          4. P2P理财系统的服务划分：
                产品服务
                            维护各种理财产品，包括订单；以及周边的东西
                撮合服务
                            1000个人借了10w（借贷服务）（标的），包装出去了各种理财产品，定期30天，定期60天，定期90天
                            （1000元，500元，1万元，统一的变成100元标细胞）                        （1000元，10w元）
                                "标的"和"理财产品"进行匹配。

                账务服务
                            记账，对账，保证不出现资损；
                出入金服务
                            对接银行系统

                营销服务（红包、优惠券）
                            维护开发各种红包、优惠券，统计运营成本等


                    我们看一个具体的理财产品下单流程：
                        一个产品1000w左右，每单1000起投，上限几万元，一般也就几千单，时间分布一般比较均匀，没有抢购现象

                        下单：
                        （1）完成校验后，同一事务内，生成初始订单（Order表，初始状态0），扣减理财产品余额（Product表，利用CAS防止超卖）；
                                update product set amount =amount -1000 where id=xx and amount -1000>0;
                            如果用户勾选了优惠券或者红包，则发送MQ消息通知"营销服务"冻结票券，
                            同时Listener接收"营销服务"冻结结果的MQ消息，更新订单信息(优惠券的状态)；
                        （2）Listener监听MQ支付消息（"出入金服务"发出），
                                更改订单（Order表）状态为已支付（1），调用"撮合服务"撮合接口，并告知订单id，金额等信息，调用"营销服务"消费冻结的票券；
                                或者更新状态为失败（2）并对产品表进行修改，调用"营销服务"释放票券；
                        （3）Listener监听MQ撮合消息（"撮合服务"发出），并更新订单状态为收益中（3）

                        收益中：
                        （4）定时任务（Quartz），每天定时更新订单"名义收益"（线程池）

                        赎回：
                        （5）订单到期当天，定时任务，调用"撮合服务"债转接口发起债转（线程池），更新订单状态为退出中（4）
                        （6）Listener监听MQ债转消息（"撮合服务"发出），债转成功，调用"出入金服务"出金接口
                        （7）Listener监听MQ打款消息（"出入金服务"发出），更新订单状态为已退出（5），短信、微信通知客户


    */
}
